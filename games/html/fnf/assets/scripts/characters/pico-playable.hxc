package funkin.play.character;

import flixel.effects.FlxFlicker;
import flixel.FlxG;
import flixel.group.FlxTypedSpriteGroup;
import flixel.tweens.FlxTween;
import flixel.util.FlxTimer;
import funkin.audio.FunkinSound;
import funkin.graphics.FunkinSprite;
import flixel.graphics.FlxGraphic;
import funkin.play.character.MultiAnimateAtlasCharacter;
import funkin.play.GameOverSubState;
import funkin.play.PauseSubState;
import funkin.play.PlayState;
import funkin.util.Constants;
import funkin.util.HapticUtil;
import funkin.Preferences;
import funkin.FunkinMemory;

class PicoPlayerBaseCharacter extends MultiAnimateAtlasCharacter
{
  public var CACHE_IMAGE_PATHS(get, never):Array<String>;

  function get_CACHE_IMAGE_PATHS():Array<String>
  {
    return ["characters/NeneKnifeToss", "weekend1:characters/pico/explosion-death/spritemap1", "weekend1:PicoBullet"];
  }

  public var CACHE_SOUND_PATHS(get, never):Array<String>;

  function get_CACHE_SOUND_PATHS():Array<String>
  {
    return ["singed_loop", "Gun_Prep", "Pico_Bonk", "shot1", "shot2", "shot3", "shot4"];
  }

  public function new(characterId:String)
  {
    // This tells CharacterDataParser to load Pico (Playable) instead of an invalid character!
    if (characterId == "UNKNOWN")
    {
      characterId = "pico-playable";
    }

    super(characterId);

    ignoreExclusionPref.push("shoot");
  }

  public override function onCreate(event:ScriptEvent):Void
  {
    super.onCreate(event);

    GameOverSubState.musicSuffix = '-pico';
    GameOverSubState.blueBallSuffix = '-pico';
    GameOverSubState.animationSuffix = '';

    PauseSubState.musicSuffix = '-pico';

    for (img in CACHE_IMAGE_PATHS)
    {
      var lib:String = Paths.getLibrary(img);
      var file:String = Paths.stripLibrary(img);

      // We don't need these graphics outside of Weekend 1.
      if (lib == "weekend1" && Paths.currentLevel != "weekend1")
      {
        continue;
      }

      FunkinMemory.cacheTexture(Paths.image(file, lib == 'preload' ? null : lib));
    }

    // We don't need these sounds outside of Weekend 1.
    if (Paths.currentLevel == "weekend1")
    {
      for (snd in CACHE_SOUND_PATHS)
      {
        FunkinMemory.cacheSound(Paths.sound(snd, "weekend1"));
      }
    }
  }

  var deathSpriteNene:FunkinSprite;

  /**
   * Initialize the death sprites.
   */
  function createDeathSprites():Void
  {
    var gf:BaseCharacter = currentStage.getGirlfriend();

    if (deathSpriteNene != null && !deathSpriteNene.alive)
    {
      deathSpriteNene.revive();
    }

    deathSpriteNene = FunkinSprite.createSparrow(0, 0, "characters/NeneKnifeToss");
    deathSpriteNene.x = gf.originalPosition.x + 120;
    deathSpriteNene.y = gf.originalPosition.y;
    deathSpriteNene.zIndex = this.zIndex - 5;
    deathSpriteNene.animation.addByPrefix('throw', "knife toss0", 24, false);
    deathSpriteNene.animation.onFinish.add(function(name:String)
    {
      deathSpriteNene.kill();
    });
  }

  public override function onNoteHit(event:HitNoteScriptEvent):Void
  {
    if (event.eventCanceled)
    {
      // onNoteHit event was cancelled by the gameplay module.
      return;
    }

    // Override the hit note animation.
    switch (event.note.kind)
    {
      case "hey":
        holdTimer = 0;
        this.playAnimation('hey', true, true);
        return;
      case "cheer":
        holdTimer = 0;
        this.playAnimation('cheer', true, true);
        return;
      case "censor":
        holdTimer = 0;
        this.playSingAnimation(event.note.noteData.getDirection(), false, 'censor');
        return;
      case "weekend-1-cockgun": // HE'S PULLING HIS COCK OUT
        holdTimer = 0;
        playCockGunAnim();
      case "weekend-1-firegun":
        holdTimer = 0;
        playFireGunAnim();
      default:
        super.onNoteHit(event);
    }
  }

  public override function onNoteMiss(event:NoteScriptEvent):Void
  {
    // Override the miss note animation.
    switch (event.note.kind)
    {
      case "weekend-1-cockgun":
        // playCockMissAnim();
      case "weekend-1-firegun":
        playCanExplodeAnim();
      default:
        super.onNoteMiss(event);
    }
  }

  public override function playAnimation(name:String, restart:Bool = false, ignoreOther:Bool = false, reversed:Bool = false):Void
  {
    // Reset the volume of the vocals to ensure that the burps always play
    if (name == "burpShit" || name == "burpSmile" || name == "burpSmileLong") PlayState.instance?.vocals?.playerVolume = 1;

    if (name == "firstDeath")
    {
      if (GameOverSubState.blueBallSuffix == '-pico-explode')
      {
        // Explosion death animation.
        doExplosionDeath();
        return;
      }
      else
      {
        // Standard death animation.
        createDeathSprites();

        GameOverSubState.instance.add(deathSpriteNene);
        deathSpriteNene.animation.play("throw");
      }
    }
    else if (name == "deathConfirm")
    {
      if (GameOverSubState.blueBallSuffix == '-pico-explode')
      {
        doExplosionConfirm();
        return;
      }
    }

    super.playAnimation(name, restart, ignoreOther, reversed);
  }

  var picoFlicker:FlxFlicker = null;

  override function onAnimationFinished(name:String)
  {
    super.onAnimationFinished(name);

    if (name == 'shootMISS' && PlayState.instance.health > 0.0 && !PlayState.instance.isPlayerDying)
    {
      // ERIC: You have to use super instead of this or it breaks.
      // This is because typeof(this) is PolymodAbstractClass.
      picoFlicker = FlxFlicker.flicker(super, 1, 1 / 30, true, true, function(_)
      {
        picoFlicker = FlxFlicker.flicker(super, 0.5, 1 / 60, true, true, function(_)
        {
          picoFlicker = null;
        });
      });
    }
  }

  public override function onPause(event:PauseScriptEvent):Void
  {
    super.onPause(event);

    if (picoFlicker != null)
    {
      picoFlicker.pause();
      this.visible = true;
    }
  }

  public override function onResume(event:ScriptEvent):Void
  {
    super.onResume(event);

    if (picoFlicker != null)
    {
      picoFlicker.resume();
    }
  }

  public override function getDeathCameraOffsets():Array<Float>
  {
    var result = super.getDeathCameraOffsets();

    if (GameOverSubState.blueBallSuffix == '-pico-explode')
    {
      return [result[0] - 10, result[1] - 40];
    }

    return [result[0], result[1]];
  }

  function doExplosionDeath():Void
  {
    if (picoFlicker != null)
    {
      picoFlicker.stop(); // this sets visible to true, but we make it false a few lines down anyways
    }

    // Suffixed death sound will already play.
    GameOverSubState.instance.resetCameraZoom();

    // Move the camera up.
    GameOverSubState.instance.cameraFollowPoint.y -= 100;

    HapticUtil.vibrate(0, 0.5);

    // Death by Darnell's can.
    FlxTimer.wait(1.85, function()
    {
      // Pico falls on his knees.
      HapticUtil.vibrate(0, 0.1, 0.1, 1);
    });

    FlxTimer.wait(3.0, afterPicoDeathExplosionIntro);
  }

  var singed:FunkinSound;

  function afterPicoDeathExplosionIntro():Void
  {
    // Start the (standard) death music, 3.5 seconds after the explosion starts,
    // not when the explosion sound finishes or when the loop starts.
    GameOverSubState.instance.startDeathMusic(1.0, false);
    singed = FunkinSound.load(Paths.sound('singed_loop'), true, false, true);
    // singed.fadeIn(0.5, 0.3, 1.0);
  }

  function doExplosionConfirm():Void
  {
    if (singed != null)
    {
      singed.stop();
      singed = null;
    }
  }

  public override function onSongRetry(event:ScriptEvent):Void
  {
    super.onSongRetry(event);

    // Don't let these pile up.
    clearCasings();

    // Reset to standard death animation.
    GameOverSubState.musicSuffix = '-pico';
    GameOverSubState.blueBallSuffix = '-pico';
    GameOverSubState.animationSuffix = '';

    PauseSubState.musicSuffix = '-pico';
  }

  function onAnimationFrame(name:String, frameNumber:Int, frameIndex:Int)
  {
    super.onAnimationFrame(name, frameNumber, frameIndex);

    if (name == "firstDeath" && frameNumber == 36 - 1)
    {
      GameOverSubState.instance.startDeathMusic(1.0, false);
      // force the deathloop to play in here, since we are starting the music early it
      // doesn't check this in gameover substate !
      // also no animation suffix ðŸ¤”
      GameOverSubState.instance.boyfriend.playAnimation('deathLoop');
    }

    if (name == "cock" && frameNumber == 3)
    {
      createCasing();
    }

    if (!HapticUtil.hapticsAvailable || GameOverSubState.blueBallSuffix == '-pico-explode') return;

    // Pico falls on his back.
    if (name == 'firstDeath' && frameNumber == 20)
    {
      HapticUtil.vibrate(0, 0.1, 0.1, 1);
    }

    // Blood firework woohoo!!!!
    if (name == 'deathLoop' && frameNumber % 2 == 0)
    {
      final randomAmplitude:Float = FlxG.random.float(0.1, 0.5);
      final randomDuration:Float = FlxG.random.float(0.1, 0.3);

      HapticUtil.vibrate(0, randomDuration, randomAmplitude);
    }
  }

  var casingGroup:FlxTypedSpriteGroup;

  function createCasing():Void
  {
    if (casingGroup == null)
    {
      casingGroup = new FlxTypedSpriteGroup();
      casingGroup.x = this.x + 250;
      casingGroup.y = this.y + 100;
      casingGroup.zIndex = 1000;
      addToStage(casingGroup);
    }

    var casing = new CasingSprite(0, 0);
    if (casing != null) casingGroup.add(casing);
  }

  function clearCasings():Void
  {
    // Clear the casing group.
    if (casingGroup != null)
    {
      casingGroup.clear();
      casingGroup = null;
    }
  }

  var picoFade:FunkinSprite;

  /**
   * Play the animation where Pico readies his gun to shoot the can.
   */
  function playCockGunAnim():Void
  {
    this.playAnimation('cock', true, true);

    var currentFrameGraphic:FlxGraphic = FlxGraphic.fromBitmapData(this.updateFramePixels(), true, null, false);

    picoFade = new FunkinSprite(this.x - 100, this.y - 200);
    picoFade.frame = currentFrameGraphic.imageFrame.frame;
    picoFade.alpha = 0.3;
    picoFade.zIndex = this.zIndex - 3;
    picoFade.updateHitbox();

    FlxTween.tween(picoFade.scale, {x: 1.3, y: 1.3}, 0.4);
    FlxTween.tween(picoFade, {alpha: 0}, 0.4);
    addToStage(picoFade);

    FunkinSound.playOnce(Paths.sound('Gun_Prep'), 1.0);
  }

  /**
   * Play the animation where Pico shoots the can successfully.
   */
  function playFireGunAnim():Void
  {
    this.playAnimation('shoot', true, true);
    FunkinSound.playOnce(Paths.soundRandom('shot', 1, 4));
  }

  /**
   * Play the animation where Pico is hit by the exploding can.
   */
  function playCanExplodeAnim():Void
  {
    this.playAnimation('shootMISS', true, true);
    // Donk.
    FunkinSound.playOnce(Paths.sound('Pico_Bonk'), 1.0);
  }

  function addToStage(sprite:FunkinSprite):Void
  {
    if (this.debug)
    {
      // We are in the chart editor or something.
      // TODO: Make this work properly.
    }
    else if (PlayState.instance != null && currentStage != null)
    {
      currentStage.add(sprite);
    }
    else
    {
      trace('Could not add sprite to stage.');
    }
  }

  public override function getDeathQuote():Null<String>
  {
    switch (PlayState.instance?.currentStage?.getDad()?.characterId)
    {
      case "tankman":
        var randomCensor:Array<Int> = [];

        if (!Preferences.naughtyness)
        {
          // 4 - fucking
          // 7 - goddamn, ass
          // 8 - fuck
          // 9 - ass, bitch
          randomCensor = [4, 7, 8, 9];
        }
        else if (Constants.CENSOR_EXPLETIVES)
        {
          randomCensor = [4, 8];
        }

        return Paths.sound('jeffGameover-pico/jeffGameover-' + FlxG.random.int(1, 10, randomCensor));
      default:
        return null;
    }
  }
}
